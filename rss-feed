<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<rss version="2.0"><channel><title>The Palavering Proffitt</title><link>http://jprof.github.io</link><description>Justin Proffitt's Blog</description><item><title>Clojure Cup 2014 Post Mortem</title><link>http://jprof.github.io/2014/10/19/Clojure-Cup-2014-Post-Mortem/</link><pubDate>Sun, 19 Oct 2014 00:00:00 -0400</pubDate><description>&lt;p&gt;I participated in &lt;a href=&quot;http://clojurecup.com&quot;&gt;Clojure Cup&lt;/a&gt; again this year, making it two years running. I worked on a team with &lt;a href=&quot;http://hannah.io&quot;&gt;hlatki&lt;/a&gt; on a simple in-browser number game slightly influenced by the style of &lt;a href=&quot;https://github.com/gabrielecirulli/2048&quot;&gt;2048&lt;/a&gt; called Number Chain. I've migrated the final source to be under my &lt;a href=&quot;https://github.com/jprof/numberchain&quot;&gt;Github&lt;/a&gt; profile and a more recent version of the game can be found &lt;a href=&quot;http://jprof.github.io/numberchain&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;&lt;h3&gt;The Idea&lt;/h3&gt;&lt;p&gt;I had been interested in making a game based on numbers since 2048 became popular earlier this year. The simplicity was appealing, and for a 48 hour competition with a focus on the browser, it made sense to try to build something like the original game 2048 browser game which worked great on mobile devices, but using ClojureScript as the core technology.&lt;/p&gt;&lt;h3&gt;What Went Well&lt;/h3&gt;&lt;p&gt;The Clojure Cup sponsors did a great job of providing the participants with development resources. We were provided servers from CloudSigma, a private Github repository to host the code, Flowdock access for team communication, among many other things. I call out the three above as they were the three provided services we used for developing Number Chain.&lt;/p&gt;&lt;p&gt;In addition to the provided services from Clojure Cup, we used a Trello board as a way to organize tasks and coordinate our work. It was very effective. Before the cup began, I populated the board with what logical tasks I could think of, haltki setup our Flowdock, and I setup a CloudSigma Image. I created a skeleton repository based off of the &lt;a href=&quot;https://github.com/astashov/perfection&quot;&gt;Perfection&lt;/a&gt; skeleton project on Github, which would allow for quick development of our application.&lt;/p&gt;&lt;p&gt;Since React.js has been such a popular library for web development this year, we decided that we should use one of the ClojureScript libraries that wraps it's functionality. We narrowed it down to &lt;a href=&quot;http://holmsand.github.io/reagent/&quot;&gt;Reagent&lt;/a&gt; and &lt;a href=&quot;https://github.com/swannodette/om&quot;&gt;Om&lt;/a&gt;. In the end we chose Reagent for it's lower learning curve.&lt;/p&gt;&lt;p&gt;Reagent ended up being a great choice. All you really need to do to get started with it is refer it's &lt;code&gt;atom&lt;/code&gt; into your namespace and use it when creating your application state. You then simply write functions that render the various pieces of the DOM (using hiccup style templates), and when anything in your application mutates the state of your atoms, the components that are using those atoms derefenced values are re-rendered.&lt;/p&gt;&lt;p&gt;A good example of this is the code used to implement the score, found in the score namespace:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj&quot;&gt;(ns number-chain.score
  (:require [reagent.core :refer [atom]]
            [clojure.string :as string]))

(def score (atom 0))

...

(defn score-component
  &amp;quot;Reagent component for the current score and high score.&amp;quot;
  []
  [:div
   [:div.score (str &amp;quot;Score &amp;quot; @score)]
   [:div.high-score (str &amp;quot;High Score &amp;quot; @high-score)]])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, the score-component dereferences the &lt;code&gt;score&lt;/code&gt; atom that is defined at the top of the namespace. In the core namespace of the application the score-component is mounted like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj&quot;&gt;(reagent/render-component [score-component] (get-element-by-id &amp;quot;score&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With the &lt;code&gt;(get-element-by-id &amp;quot;score&amp;quot;)&lt;/code&gt; returning a DOM element for the component to be rendered into, which in this case is a div. With that done, anything in the application that modifies the &lt;code&gt;score&lt;/code&gt; atom will cause the &lt;code&gt;score-component&lt;/code&gt; to be re-rendered automatically.&lt;/p&gt;&lt;p&gt;Overall, Reagent fit our needs well for Number Chain as the scope of the project was relatively small. I can see a stronger argument for Om for projects that are going to be significantly more complex, but for something quick and simple Reagent really shines, in fact it ships default with the &lt;a href=&quot;http://www.luminusweb.net/&quot;&gt;Luminus&lt;/a&gt; Clojure Web Framework.&lt;/p&gt;&lt;h3&gt;What Didn't Go Well&lt;/h3&gt;&lt;p&gt;For the portions of the competition that didn't go well, one thing really sticks out: CSS. I've always avoided CSS as for the most part I've not done a significant amount of front-end web development. That really bit me for this project. hlatki has more experience in this regard, and ended up getting the look and feel of Number Chain to where it was. Despite this, it still took a significant amount of time for both of us, time that could have been better spent working on some of the stretch goals we had for the application.&lt;/p&gt;&lt;p&gt;Another pain point related to the front end web development was timing quirks and events. The simple case of clicking just worked, and that is how we trigger a selection toggle on the cells when you use your mouse:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj&quot;&gt;(defn small-cell
  &amp;quot;Takes a single value from the :numbers app-state value and produces the cell
   that represents that number. Properly sets the bg color and data-id tag
   fields.&amp;quot;
  [{:keys [value id]}]
  [div-grid-col {:style {:border &amp;quot;1px solid #d3d3d3&amp;quot;
                         :background (if ((:selected @app-state) id)
                                       (:selection-color @app-state)
                                       &amp;quot;#009bcc&amp;quot;)}
                 :data-id id
                 :id (str &amp;quot;grid-&amp;quot; id)
                 :on-click toggle-selected}
   value])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, this is embedded into the actual HTML generated when the reagent component is rendered, so it just works. Unfortunately, for a mobile based environment we have to add the touch listener in raw Javascript, which we did with this function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj&quot;&gt;(defn attach-touch-listeners!
  &amp;quot;Add the touch listeners to all of the grid-cell divs in our game. Needs
   to happen after each rendering of the game grid.&amp;quot;
  []
  (let [els (get-elements-by-class-name &amp;quot;grid-cell&amp;quot;)
        size (.-length els)]
    (doseq [e (range size)]
      (.addEventListener (aget els e) &amp;quot;touchstart&amp;quot; toggle-selected))))

;; Actually called via:
(js/setTimeout #(attach-touch-listeners!) 50)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The timeout above was needed to handle issues we saw due to a delay in when the applications state was modified to start the game and when the actual grid cells were rendered. Without the delay, there were no element to attach the touch listeners to. Unfortunately, it took a bit of time to discover this, and then fix it.&lt;/p&gt;&lt;h3&gt;In the End...&lt;/h3&gt;&lt;p&gt;We had a great time. It was a nice way to spend a weekend working on something for fun, trying out new things, and having something (semi-)polished to show off. I look forward to the next Clojure Cup! In the mean time I'm going to be looking at CSS a bit more, in addition to all the exciting things happening in the Clojure/ClojureScript space.&lt;/p&gt;</description></item><item><title>Getting started with ClojureScript</title><link>http://jprof.github.io/2013/11/21/getting-started-with-clojurescript/</link><pubDate>Thu, 21 Nov 2013 00:00:00 -0500</pubDate><description>&lt;p&gt;I recently attended &lt;a href=&quot;http://clojure-conj.org/&quot;&gt;Clojure Conj&lt;/a&gt; and had a wonderful time. I've been doing things in Clojure whenever I can find a good fit for it, but at the conference I was inspired to take a look at ClojureScript when I saw &lt;a href=&quot;http://github.com/MarcoPolo&quot;&gt;MarcoPolo&lt;/a&gt;'s &lt;a href=&quot;http://github.com/MarcoPolo/Transcience&quot;&gt;Transcience&lt;/a&gt; game which was written in ClojureScript.&lt;/p&gt;&lt;p&gt;I sat down last night with aspirations to dig in and get something started (likely a game for the &lt;a href=&quot;https://github.com/blog/1674-github-game-off-ii&quot;&gt;Github Gameoff&lt;/a&gt;) but quickly realized that ClojureScript development didn't flow quite as smoothly as Clojure development. My impression so far has been that this is mostly due to the short time ClojureScript has been in the wild. With that said, I wanted to outline my first steps, where I went wrong, and specifically: how to get a browser attached ClojureScript repl going.&lt;/p&gt;&lt;h3&gt;Getting Started&lt;/h3&gt;&lt;p&gt;I'm going to assume that you already have lein installed. If not, the installation is very simple and can be found on the &lt;a href=&quot;http://github.com/technomancy/leiningen&quot;&gt;leiningen&lt;/a&gt; github page.&lt;/p&gt;&lt;p&gt;The first step, as always, is to create a new project.&lt;/p&gt;&lt;p&gt;&lt;code&gt;lein new try-cljs&lt;/code&gt;&lt;/p&gt;&lt;p&gt;We next need to edit our project.clj file to pull in ClojureScript. This can be done by adding &lt;code&gt;[org.clojure/ClojureScript &amp;quot;0.0.2030&amp;quot;]&lt;/code&gt; to the &lt;code&gt;:dependencies&lt;/code&gt; vector. We will also want the &lt;a href=&quot;https://github.com/emezeske/lein-cljsbuild&quot;&gt;lein-cljsbuild&lt;/a&gt; plugin. Add a &lt;code&gt;:plugin&lt;/code&gt; keyword with &lt;code&gt;[[lein-cljsbuild &amp;quot;1.0.0&amp;quot;]]&lt;/code&gt; as the value to accomplish this.&lt;/p&gt;&lt;p&gt;The lein-cljsbuild plugin is configured via the &lt;code&gt;:cljsbuild&lt;/code&gt; key, taking a map as the value. We'll use something similar to what's found in the &lt;a href=&quot;https://github.com/emezeske/lein-cljsbuild/blob/1.0.0/example-projects/simple/project.clj&quot;&gt;simple example project&lt;/a&gt; of the lein-cljsbuild github repo. It looks something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj linenums&quot;&gt;:builds [{:source-paths [&amp;quot;src-cljs&amp;quot;]
          :compiler {:output-to &amp;quot;js/main.js&amp;quot;
                     :output-dir &amp;quot;out&amp;quot;
                     :pretty-print true}}]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point your project.clj contents should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj linenums&quot;&gt;(defproject try-cljs &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies [[org.clojure/clojure &amp;quot;1.5.1&amp;quot;]
                 [org.clojure/clojurescript &amp;quot;0.0-2030&amp;quot;]]
  :plugins [[lein-cljsbuild &amp;quot;1.0.0&amp;quot;]]
  :cljsbuild {:builds [{:source-paths [&amp;quot;src-cljs&amp;quot;]
                        :compiler {:output-to &amp;quot;js/main.js&amp;quot;
                                   :output-dir &amp;quot;out&amp;quot;
                                   :pretty-print true}}]})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now run &lt;code&gt;lein deps&lt;/code&gt; to pull these dependencies. Once that has finished, it's time to write some ClojureScript! Since we have specified in our project.clj that our cljs src is in &lt;code&gt;src-cljs&lt;/code&gt;, we must make this directory. &lt;code&gt;mkdir -p
src-cljs/try-cljs/&lt;/code&gt;. Now, using your favorite editor, let's create &lt;code&gt;hello.cljs&lt;/code&gt; in this new directory.&lt;/p&gt;&lt;p&gt;Add this to the contents of the file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj linenums&quot;&gt;(ns try-cljs.hello)

(js/alert &amp;quot;Hello World!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Save that, and run the &lt;code&gt;lein cljsbuild once&lt;/code&gt; which will compile this file, placing the output into &lt;code&gt;js/main.js&lt;/code&gt; and &lt;code&gt;out/&lt;/code&gt;. This is nice, but now we need an html file to get this going in a browser. Create a file in the root of your directory &lt;code&gt;hello.html&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-html linenums&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;script src=&amp;quot;js/main.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;goog.require(&amp;quot;try_cljs.hello&amp;quot;);&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, you should be able to open this page in your browser. When you do you should see the javascript alert pop up with &quot;Hello World!&quot; as the message.&lt;/p&gt;&lt;h3&gt;That was fun, but...&lt;/h3&gt;&lt;p&gt;So, now we have some ClojureScript compiling to javascript and running, but we're missing an important piece of our tool chain that makes Clojure a joy to work with: the REPL. Let's get that up and running next.&lt;/p&gt;&lt;p&gt;There are a few ways to get a repl running, for this post we will use the repl-listen option provided by lein-cljsbuild. First we must modify our hello.cljs file to look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-clj linenums&quot;&gt;(ns try-cljs.hello
  (:require [clojure.browser.repl :as repl]))

(repl/connect &amp;quot;http://localhost:9000/repl&amp;quot;)

(js/alert &amp;quot;Hello World!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Save and run &lt;code&gt;lein trampoline cljsbuild auto&lt;/code&gt;. This differs from the &lt;code&gt;lein
cljsbuild once&lt;/code&gt; in that we are only keeping the java instance that lein requires long enough to get our clojure process in proper order and for cljsbuild to monitor the cljs files for changes and auto compile them when they change. This is particuarly useful as we do not have to wait for the JVM to fire up everytime we want to compile, but at the price that a JVM instance stays alive until we kill the process.&lt;/p&gt;&lt;p&gt;Next, run &lt;code&gt;lein trampoline cljsbuild repl-listen&lt;/code&gt;. This will fire up a ClojureScript REPL and you should see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Running ClojureScript REPL, listening on port 9000.
To quit, type: :cljs/quit
ClojureScript:cljs.user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, it's time to try out our page again. Instead of opening &lt;code&gt;hello.html&lt;/code&gt; directly, navigate your browser to &lt;code&gt;http://localhost:9000/hello.html&lt;/code&gt;. You should now see the same javascript alert from earlier. Now, in the ClojureScript REPL, we can interact with the page we just navigated to. Run &lt;code&gt;(js/alert &amp;quot;The REPL works&amp;quot;)&lt;/code&gt; from the REPL. The message should appear as we would expect. &lt;/p&gt;&lt;h3&gt;All your browsers are belong to us?&lt;/h3&gt;&lt;p&gt;That is culmination of the knowledge I gained while working through the documentation for getting a ClojureScript REPL running in the browser. I particuarly struggled with connecting to the REPL as it was not immediately obvious how the connection was made. Google ended up not being much help, until I found this &lt;a href=&quot;https://groups.google.com/forum/#!msg/clojure/BQa9WkRvloo/tyMnl0eWKFMJ&quot;&gt;google group thread&lt;/a&gt;. I discovered that all I needed to do was navigate to the &lt;code&gt;http://localhost:9000/&lt;/code&gt;, not &lt;code&gt;http://localhost:9000/repl&lt;/code&gt;. I was also using index.html instead of hello.html last night, hopefully this distinction is helpful in the URI's as I did not realize that port 9000 was serving pages from the root of my project. &lt;/p&gt;&lt;p&gt;I'm excited to experiment more with Clojure and ClojureScript. I'm likely going to give cemerick's &lt;a href=&quot;https://github.com/cemerick/austin&quot;&gt;Austin&lt;/a&gt; a go next. I've created a github repository &lt;a href=&quot;https://github.com/jprof/cljs-browser-repl-tutorial&quot;&gt;here&lt;/a&gt; that contains the complete code written in this post, so if you don't want to type it all out, go ahead and clone it!&lt;/p&gt;</description></item><item><title>Ludum Dare 27 Post Mortem</title><link>http://jprof.github.io/2013/09/04/ludum-dare-27-post-mortem/</link><pubDate>Wed, 4 Sep 2013 00:00:00 -0400</pubDate><description>&lt;p&gt;This time around I've managed to get to writing this in a more timely fashion. Ludum Dare 27 was almost two weeks ago, and so the judging is still going on for my entry &quot;Get to the Choppa!&quot;. Overall this Ludum Dare went much smoother than the previous. The theme this time around was &quot;10 Seconds&quot; which lent itself to the game idea I had in mind. &lt;/p&gt;&lt;h2&gt;The Idea&lt;/h2&gt;&lt;p&gt;Learning from the experience I had in Ludum Dare 26, I decided that having a better defined idea for the game &lt;em&gt;before&lt;/em&gt; the theme was announced would make the development go much smoother. I had been playing &lt;a href=&quot;http://store.steampowered.com/app/233740/&quot;&gt;Organ Trail&lt;/a&gt; when I had time to kill in July and August, and I was enjoying the simplicity of the scavenging missions. I knew that I wouldn't be devoting the full weekend to this Ludum Dare like I had the last, so I thought aiming for gameplay similar to this for my entry would be reasonable. I also loved the retro style of Organ Trail, and so I wanted the game to be visually similar. &lt;/p&gt;&lt;p&gt;The Saturday before Ludum Dare I happened to re-watch &lt;a href=&quot;http://www.youtube.com/watch?v=qlicWUDf5MM&quot;&gt;this awesome Predator video&lt;/a&gt; and &lt;a href=&quot;http://www.youtube.com/watch?v=-9-Te-DPbSE&quot;&gt;&quot;GET TO THE CHOPPA!&quot;&lt;/a&gt; popped into my head. I knew now what the goal of every level of my game would be: Getting to that choppa! Since CoffeeScript and Crafty.js hadn't been a bad experience, I decided to use them again for implementing the game. I described the idea to some of my friends and luckily they wanted to help. When it came time for the theme to be announced it could not have been more perfect: &quot;10 Seconds&quot;. More like: &quot;10 Seconds to get to the choppa!&quot;.&lt;/p&gt;&lt;h2&gt;Getting to the Choppa!&lt;/h2&gt;&lt;p&gt;We didn't get started until late in the day Saturday. I wanted to reuse any components that we could from &lt;a href=&quot;https://github.com/jprof/ludumdare26&quot;&gt;MetroGnome&lt;/a&gt;, however the way most were implemented they were not easy to drop in the way I had hoped. In the end we used this code as a reference for where to begin when we had questions with how to do something. Specifically, I had not touched anything with sprites when we worked on MetroGnome, so being able to see how this was implemented in MetroGnome was awesome.&lt;/p&gt;&lt;p&gt;Since the team working on &lt;em&gt;Get to the Choppa!&lt;/em&gt; was smaller this time around it was much easier to divvy work out and implement features concurrently. While I was working on loading assets and animating the sprites others were working on enemy movement and bullets. Since we had an idea of what we wanted the game to play like and how it should look, the art quickly came together, in fact it was finished two or three hours after we started working.&lt;/p&gt;&lt;p&gt;What that went well:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Graphics&lt;/li&gt;
  &lt;li&gt;Having a concept before the theme was announced&lt;/li&gt;
  &lt;li&gt;Gameplay&lt;/li&gt;
  &lt;li&gt;Smaller team&lt;/li&gt;
  &lt;li&gt;Smaller scope&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;What could have been better:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CoffeeScript/JavaScript can resemble insanity&lt;/li&gt;
  &lt;li&gt;We still need more experience with Crafty.js&lt;/li&gt;
  &lt;li&gt;No sound&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Overall this Ludum Dare flowed much better than the previous one. Having a concept before the competition started was huge, as well as having a smaller team and scope. Despite going better overall, I still found myself working on the project up to the deadline. When I reached the point where it was time to implement the level loader, I kept finding bugs. Part of this is due to the dynamic nature of JavaScript. It's easy to develop something quickly with JavaScript or CoffeeScript, but it's a pain to debug.&lt;/p&gt;&lt;p&gt;Despite it's flaws, I'm still happy with the outcome: &lt;a href=&quot;http://jprof.github.io/ludumdare27&quot;&gt;Get to the Choppa!&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;Next Time&lt;/h2&gt;&lt;p&gt;So, after participating in the last two Ludum Dare Game Jams, I've definitely found that having a concept prior to the event is huge and I will most certainly have an idea before the next one. I've used Crafty.js and CoffeeScript for both competitions, and despite the rough spots I will likely use them again. I would really like to take some of the pieces that we developed for &lt;em&gt;MetroGnome&lt;/em&gt; and &lt;em&gt;Get to the Choppa!&lt;/em&gt; and work on their design so that we can potentially reuse them in the next Ludum Dare. I also feel that getting the level loader up earlier (this was the last piece I worked on) would be huge. The game didn't feel like a game until the levels were loading. &lt;/p&gt;&lt;p&gt;The next Ludum Dare will be sometime in December. I hope to devote more time to it than I did for this one. &lt;/p&gt;</description></item><item><title>Ludum Dare 26 Post Mortem</title><link>http://jprof.github.io/2013/06/23/ludum-dare-26-post-mortem/</link><pubDate>Sun, 23 Jun 2013 00:00:00 -0400</pubDate><description>&lt;p&gt;This is coming a bit late... it has been a while since Ludum Dare 26! I have had a lot going on with my family and work so I'm just now getting around to writing this.&lt;/p&gt;&lt;p&gt;For those of you who are not familiar with &lt;a href=&quot;http://www.ludumdare.com/compo/&quot;&gt;Ludum Dare&lt;/a&gt;, it is a game development competition. It is consists of two events: an individual, two day competition that has a strict set of rules, and a more laid-back, team-based, three day game jam.&lt;/p&gt;&lt;p&gt;We participated in the jam! Our team consisted of five programmers and one artist. This was our first time participating in a Ludum Dare event which made it a fun and interesting experience. &lt;/p&gt;&lt;p&gt;Before going into the minute details, here are the canonical &quot;what went well and what didn't go well&quot; lists.&lt;/p&gt;&lt;p&gt;What went well:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Graphics&lt;/li&gt;
  &lt;li&gt;CoffeeScript&lt;/li&gt;
  &lt;li&gt;Sharing the same workspace&lt;/li&gt;
  &lt;li&gt;Github&lt;/li&gt;
  &lt;li&gt;Streamlined build process&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;What could have been better:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Gameplay&lt;/li&gt;
  &lt;li&gt;CraftyJS&lt;/li&gt;
  &lt;li&gt;CoffeeScript(!?)&lt;/li&gt;
  &lt;li&gt;The theme&lt;/li&gt;
  &lt;li&gt;Inexperienced team&lt;/li&gt;
  &lt;li&gt;Bottle-necked workload&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Prequel&lt;/h2&gt;&lt;p&gt;Before the competition, we decided on using JavaScript and Crafty to write the game. CoffeeScript was later chosen over JavaScript due to it's cleaner and more succinct syntax (thanks to a brief love affair with &lt;a href=&quot;http://nodewar.com/&quot;&gt;Node Wars&lt;/a&gt;). With this knowledge, I prepared a local server that each of us could push our current build to in order to efficiently show the progress we were making. All of us are Vim users so we installed the awesome plugins &lt;a href=&quot;https://github.com/scrooloose/syntastic&quot;&gt;syntastic&lt;/a&gt; and &lt;a href=&quot;https://github.com/kchmck/vim-coffee-script&quot;&gt;vim-coffee-script&lt;/a&gt; to assist us with CoffeeScript syntax, linting, and compiling.&lt;/p&gt;&lt;h2&gt;The Game&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Minimalism&lt;/em&gt; was the theme of this Ludum Dare. We talked through our game ideas and landed on using sound as the core game mechanic. We eventually came up with the idea of using a gnome as the main character. The specifics of the sound mechanic evolved into a metronome-like beat; its' purpose was to signify when the player could move. Thus, Metrognome was born.&lt;/p&gt;&lt;p&gt;In Metrognome, the beat is tied to the movement of the player. The speed of the gnomes' movement was tied to the accuracy of hitting the directional key with the beat. Accurate timing results in the gnome dashing quickly in that direction. With this design in mind, the next step was coding and developing the art.&lt;/p&gt;&lt;p&gt;Since most of us had never used CoffeeScript or Crafty, there was a considerable amount of flailing involved. The vim-coffee-script plugin was useful for the minor mistakes so we slowly made progress. A bigger problem for us was the Crafty documentation; we often had to resort to looking through the source for answers instead of their published docs.&lt;/p&gt;&lt;p&gt;Our team composition and lack of experience plus the short duration of the jam did not work in our favor. The first two days proved difficult for more than two of our programmers to work in parallel; our code base was not large enough for our team. Fortunately, the third day went better in this regard; the code base had grown large enough for each of us to have a task that would not trample others work.&lt;/p&gt;&lt;p&gt;Our experience with Crafty was also an issue. Crafty is built as an &lt;a href=&quot;http://roguebasin.roguelikedevelopment.org/index.php?title=Entity_Component_System&quot;&gt;Entity Component System&lt;/a&gt; and this was a new design paradigm for most of us. Some of the components we wrote resembled objects from the Object Oriented school of thought more than what an ECS component actually should use. &lt;/p&gt;&lt;p&gt;Despite our struggles with Crafty and our inexperience with CoffeeScript, we were able to finish with a semi-working game. The graphics and art style turned out great! It can be found &lt;a href=&quot;http://jprof.github.io/ludumdare26&quot;&gt;here&lt;/a&gt; and the source &lt;a href=&quot;https://github.com/jprof/ludumdare26&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Hello World</title><link>http://jprof.github.io/2013/04/12/title/</link><pubDate>Fri, 12 Apr 2013 00:00:00 -0400</pubDate><description>&lt;p&gt;This being my first post, it feels right to include a hello world program. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint lang-c linenums&quot;&gt;#include &amp;quot;stdio.h&amp;quot;

int main(int argc, char* argv[])
{
    printf(&amp;quot;Hello World!\n&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>